1. Architecture Overview

You can use SafeMessage AI as the backend model via the OpenAI API, and build your own frontend + authentication + payment layers.

A simple architecture:

Frontend (React / Vue / HTML)
   â†“
Backend (Node.js / Python Flask)
   â†“
OpenAI API (SafeMessage AI via Assistants API)

2. Using SafeMessage AI as a Backend

Youâ€™d:

Create an Assistant via the OpenAI Assistants API
.

Load your current SafeMessage AI instructions into that assistant.

Expose an endpoint (e.g., /analyze) that:

Accepts message input.

Forwards it to your Assistant.

Returns the formatted verdict.

That way, your web app simply calls your backend â€” not OpenAI directly from the browser.

ðŸ§  3. Free Tier Logic

Implement simple usage tracking:

Use a database (e.g., Supabase, Firebase, PostgreSQL) to store user IDs and count the number of free checks.

When the counter exceeds 5, block requests or show an upgrade prompt.

Example pseudo-flow:

if (user.free_checks < 5) {
  analyzeMessage();
  user.free_checks += 1;
} else if (user.isPremium) {
  analyzeMessage();
} else {
  showUpgradeModal();
}

ðŸ’³ 4. Premium Tier Options

Easiest options:

Stripe Checkout
 for recurring $5/month subscriptions.

Lemon Squeezy
 if you want a â€œno-codeâ€ payment and license system.

Connect subscription verification to your backend (e.g., store user.isPremium = true after successful payment webhook).

ðŸŒ 5. Hosting Options

Frontend: Vercel, Netlify, or Cloudflare Pages.

Backend/API: Vercel serverless functions, Render, or Fly.io.

Database/Auth: Supabase (great for small apps).

ðŸ” 6. Security & Privacy

Never store full message content â€” just hashed or truncated text for logs.

Use HTTPS, and if you store messages, comply with basic privacy standards (GDPR-style transparency).

Would you like me to sketch out a starter architecture diagram or code scaffold (e.g., using Node.js + Stripe + OpenAI API) for this?


=========== MY INSTRUCTIONS =====
Ok, what I need from you at this point is step by step copy and paste code for a "hosted on vercel" version of this that uses our GPT as the backend.
===========

Awesomeâ€”hereâ€™s a copy-paste, Vercel-ready Next.js app that uses your GPT (SafeMessage AI) as the backend, includes 5 free checks per device, and a $5/mo premium using Stripe. Itâ€™s minimal but complete: just drop these files in, set env vars, and deploy.

0) Project Setup
# create app
npx create-next-app@latest safemessage-web --typescript --eslint
cd safemessage-web

# add deps
npm i openai stripe @vercel/kv uuid
npm i -D @types/stripe

1) .env.local (create this)
# Core
OPENAI_API_KEY=sk-...
NEXT_PUBLIC_SITE_URL=http://localhost:3000

# Stripe
STRIPE_SECRET_KEY=sk_live_or_test_...
STRIPE_PRICE_ID=price_12345      # your $5/mo price
STRIPE_WEBHOOK_SECRET=whsec_...   # from Stripe CLI or dashboard

# Vercel KV (Upstash) â€” set these after you add KV integration on Vercel
KV_URL=
KV_REST_API_URL=
KV_REST_API_TOKEN=
KV_REST_API_READ_ONLY_TOKEN=


On Vercel: add Vercel KV (or Upstash Redis) integration to your project; the four KV vars populate automatically.

2) package.json (replace scripts with these)
{
  "name": "safemessage-web",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "stripe:listen": "stripe listen --forward-to localhost:3000/api/stripe/webhook"
  },
  "dependencies": {
    "@vercel/kv": "^1.0.1",
    "openai": "^4.58.1",
    "stripe": "^16.9.0",
    "uuid": "^9.0.1"
  },
  "devDependencies": {
    "@types/stripe": "^11.25.0",
    "@types/node": "22.7.4",
    "eslint": "9.13.0",
    "eslint-config-next": "15.0.3",
    "typescript": "5.6.3",
    "next": "15.0.3",
    "react": "18.3.1",
    "react-dom": "18.3.1"
  }
}

3) vercel.json (optional but helpful)
{
  "routes": [
    { "src": "/api/stripe/webhook", "dest": "/api/stripe/webhook" }
  ]
}

4) app/layout.tsx
export const metadata = {
  title: "SafeMessage AI",
  description: "Check messages for phishing and scam risks"
};

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body style={{ fontFamily: "ui-sans-serif, system-ui, -apple-system", background: "#0b1120", color: "white" }}>
        <div style={{ maxWidth: 800, margin: "0 auto", padding: 24 }}>{children}</div>
      </body>
    </html>
  );
}

5) app/page.tsx â€“ Minimal UI
"use client";

import { useEffect, useState } from "react";

type Analysis = {
  verdict: "SAFE" | "UNSAFE" | "UNKNOWN";
  threatLevel: string;
  text: string; // full formatted block
};

export default function HomePage() {
  const [sender, setSender] = useState("");
  const [body, setBody] = useState("");
  const [context, setContext] = useState("");
  const [result, setResult] = useState<Analysis | null>(null);
  const [loading, setLoading] = useState(false);
  const [usage, setUsage] = useState<{ used: number; limit: number; premium: boolean }>({ used: 0, limit: 5, premium: false });
  const [email, setEmail] = useState("");

  useEffect(() => {
    fetch("/api/usage").then(r => r.json()).then(setUsage).catch(() => {});
  }, []);

  const analyze = async () => {
    setLoading(true);
    setResult(null);
    try {
      const res = await fetch("/api/analyze", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ sender, body, context })
      });

      if (res.status === 402) {
        const data = await res.json();
        if (confirm("You've hit the free limit. Upgrade to premium?")) {
          const pay = await fetch("/api/stripe/checkout", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ email })
          });
          const { url } = await pay.json();
          if (url) window.location.href = url;
        }
        return;
      }

      const data = await res.json();
      setResult(data);
      const u = await fetch("/api/usage").then(r => r.json());
      setUsage(u);
    } catch (e) {
      alert("Something went wrong.");
    } finally {
      setLoading(false);
    }
  };

  const openPortal = async () => {
    const res = await fetch("/api/stripe/portal", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({}) });
    const data = await res.json();
    if (data.url) window.location.href = data.url;
  };

  return (
    <main>
      <h1 style={{ fontSize: 28, fontWeight: 700, marginBottom: 8 }}>SafeMessage AI</h1>
      <p style={{ color: "#9CA3AF", marginBottom: 20 }}>
        Check if a message is SAFE, UNSAFE, or UNKNOWN. 5 free checks, then $5/mo unlimited.
      </p>

      <div style={{ background: "#111827", padding: 16, borderRadius: 12, marginBottom: 16 }}>
        <label>Upgrade email (for premium): </label>
        <input
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          placeholder="you@example.com"
          style={{ width: "100%", marginTop: 6, padding: 10, borderRadius: 8, color: "white", background: "#1F2937", border: "1px solid #374151" }}
        />
      </div>

      <div style={{ background: "#111827", padding: 16, borderRadius: 12 }}>
        <div style={{ display: "grid", gap: 12 }}>
          <input
            value={sender}
            onChange={(e) => setSender(e.target.value)}
            placeholder="Sender/From (e.g., 'support@bank.com' or '+1 555-...')"
            style={{ padding: 10, borderRadius: 8, color: "white", background: "#1F2937", border: "1px solid #374151" }}
          />
          <textarea
            value={body}
            onChange={(e) => setBody(e.target.value)}
            placeholder="Paste the message body here..."
            rows={8}
            style={{ padding: 10, borderRadius: 8, color: "white", background: "#1F2937", border: "1px solid #374151" }}
          />
          <input
            value={context}
            onChange={(e) => setContext(e.target.value)}
            placeholder="Optional context (your relationship with sender, recent activity, etc.)"
            style={{ padding: 10, borderRadius: 8, color: "white", background: "#1F2937", border: "1px solid #374151" }}
          />

          <button
            onClick={analyze}
            disabled={loading || !body}
            style={{ padding: "10px 14px", borderRadius: 8, background: loading ? "#4B5563" : "#22c55e", color: "black", fontWeight: 700 }}
          >
            {loading ? "Analyzing..." : "Analyze"}
          </button>
        </div>
      </div>

      <div style={{ marginTop: 16, display: "flex", gap: 12, alignItems: "center" }}>
        <span style={{ fontSize: 14, color: "#9CA3AF" }}>
          Usage: {usage.used}/{usage.premium ? "âˆž" : usage.limit} {usage.premium ? "(Premium)" : ""}
        </span>
        {usage.premium ? (
          <button onClick={openPortal} style={{ padding: "6px 10px", borderRadius: 6, background: "#14b8a6", color: "black", fontWeight: 700 }}>Manage Billing</button>
        ) : (
          <button onClick={async () => {
            const res = await fetch("/api/stripe/checkout", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ email }) });
            const data = await res.json();
            if (data.url) window.location.href = data.url;
          }} style={{ padding: "6px 10px", borderRadius: 6, background: "#fbbf24", color: "black", fontWeight: 700 }}>
            Upgrade ($5/mo)
          </button>
        )}
      </div>

      {result && (
        <pre style={{ background: "#0b1220", marginTop: 16, padding: 16, borderRadius: 12, whiteSpace: "pre-wrap", border: "1px solid #1F2937" }}>
{result.text}
        </pre>
      )}
    </main>
  );
}

6) lib/kv.ts
import { kv } from "@vercel/kv";

export const getKV = () => kv; // thin wrapper in case you want to swap later

7) lib/safeMessagePrompt.ts
export const SAFE_MESSAGE_SYSTEM_PROMPT = `
You are SafeMessage AI, a digital safety assistant that helps users determine whether a pasted message, email, or uploaded screenshot is likely SAFE, UNSAFE, or UNKNOWN. You analyze sender info, message text, tone, links, requests, and language patterns for signs of phishing, scams, or social engineering.

You must always collect key details (Sender/From, Message Body, optional Context). Analyze for risk patterns, and output a verdict (SAFE / UNSAFE / UNKNOWN) with short reasoning and next steps. Use clear, calm, non-technical language. Respect privacy; do not request unnecessary personal data.

Classification:
âœ… SAFE â€” No strong scam indicators.
âš ï¸ UNSAFE â€” Clear or likely fraud/phishing/social-engineering indicators.
â“ UNKNOWN â€” Insufficient or mixed signals.

When unsure, lean toward UNSAFE to prioritize user safety.

Threat Level System (0â€“100%):
Always include a Threat Level % and risk band (Low, Medium, High, Critical), plus a one-line explanation.

Threat Bands:
0â€“9%: Low
10â€“39%: Medium
40â€“69%: High
70â€“100%: Critical

Scoring (examples):
- Real domain, clean links: 0â€“5%
- Domain mismatch: +15â€“25%
- Obvious fake domain: 100%
- Mismatched links: +30â€“50%
- Requests for codes, payments, credentials: +30â€“60%
- Urgent tone: +20â€“40%
- Poor grammar: +10â€“20%

Response block format:
ðŸ” SafeMessage AI Analysis

Verdict: [SAFE | UNSAFE | UNKNOWN]

Threat Level: [NN% (Low/Medium/High/Critical)]
Why (brief): [short cause]

Reasoning:
â€¢ 1â€“4 concise bullets

Next Steps:
1â€“2 practical suggestions

If UNKNOWN: advise verifying via official site/number and avoid clicking links.

Educate Feedback Commands:
/fp, /fn, /educate â†’ compact JSON log.

Safety & Privacy: Never ask for or echo sensitive identifiers in full.

Friendly, calm, educational tone. No guarantees or legal claims.

Disclaimer: â€œSafeMessage AI provides educational guidance and risk signals. It does not provide legal, financial, or security guarantees. Always verify via official channels.â€
`;

8) app/api/_session.ts â€“ simple device cookie (no auth)
import { cookies } from "next/headers";
import { v4 as uuid } from "uuid";

const COOKIE_NAME = "safemessage_uid";
export function getOrCreateUid() {
  const store = cookies();
  let uid = store.get(COOKIE_NAME)?.value;
  if (!uid) {
    uid = uuid();
    // httpOnly cookie so users can't tamper easily
    store.set(COOKIE_NAME, uid, { httpOnly: true, path: "/", sameSite: "lax", maxAge: 60 * 60 * 24 * 365 });
  }
  return uid;
}

9) app/api/analyze/route.ts
import { NextRequest, NextResponse } from "next/server";
import OpenAI from "openai";
import { SAFE_MESSAGE_SYSTEM_PROMPT } from "@/lib/safeMessagePrompt";
import { getOrCreateUid } from "../_session";
import { getKV } from "@/lib/kv";

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY! });
const FREE_LIMIT = 5;

export async function POST(req: NextRequest) {
  const { sender = "", body = "", context = "" } = await req.json().catch(() => ({}));
  if (!body || typeof body !== "string") {
    return NextResponse.json({ error: "Missing message body" }, { status: 400 });
  }

  const uid = getOrCreateUid();
  const kv = getKV();

  const premium = (await kv.get<boolean>(`premium:${uid}`)) || false;
  let used = (await kv.get<number>(`usage:${uid}`)) || 0;

  if (!premium && used >= FREE_LIMIT) {
    return NextResponse.json({ error: "Free limit reached" }, { status: 402 });
  }

  // Increment usage pre-call for consistency; you can move post-call if desired
  if (!premium) {
    used += 1;
    await kv.set(`usage:${uid}`, used);
  }

  const userContent = [
    `Sender/From: ${sender || "(not provided)"}`,
    `Message Body: ${body}`,
    `Context: ${context || "(not provided)"}`
  ].join("\n");

  // Use Chat Completions for deterministic formatting
  const completion = await openai.chat.completions.create({
    model: "gpt-4o-mini",
    temperature: 0.2,
    messages: [
      { role: "system", content: SAFE_MESSAGE_SYSTEM_PROMPT },
      { role: "user", content: userContent }
    ]
  });

  const text = completion.choices[0]?.message?.content ?? "No response.";

  // Try to extract minimal structured bits for UI display
  const verdictMatch = text.match(/Verdict:\s*(SAFE|UNSAFE|UNKNOWN)/i);
  const threatMatch = text.match(/Threat Level:\s*([^\n]+)/i);

  return NextResponse.json({
    text,
    verdict: (verdictMatch?.[1]?.toUpperCase() ?? "UNKNOWN") as "SAFE" | "UNSAFE" | "UNKNOWN",
    threatLevel: threatMatch?.[1] ?? "N/A"
  });
}

10) app/api/usage/route.ts
import { NextResponse } from "next/server";
import { getKV } from "@/lib/kv";
import { getOrCreateUid } from "../_session";

const FREE_LIMIT = 5;

export async function GET() {
  const uid = getOrCreateUid();
  const kv = getKV();
  const used = (await kv.get<number>(`usage:${uid}`)) || 0;
  const premium = (await kv.get<boolean>(`premium:${uid}`)) || false;

  return NextResponse.json({ used, limit: FREE_LIMIT, premium });
}

11) app/api/stripe/checkout/route.ts
import { NextRequest, NextResponse } from "next/server";
import Stripe from "stripe";
import { getOrCreateUid } from "../../_session";

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, { apiVersion: "2024-06-20" });

export async function POST(req: NextRequest) {
  const { email } = await req.json().catch(() => ({}));
  const uid = getOrCreateUid();

  const session = await stripe.checkout.sessions.create({
    mode: "subscription",
    customer_email: email || undefined,
    line_items: [{ price: process.env.STRIPE_PRICE_ID!, quantity: 1 }],
    success_url: `${process.env.NEXT_PUBLIC_SITE_URL}/?status=success`,
    cancel_url: `${process.env.NEXT_PUBLIC_SITE_URL}/?status=cancel`,
    metadata: { uid },
  });

  return NextResponse.json({ url: session.url });
}

12) app/api/stripe/portal/route.ts
import { NextRequest, NextResponse } from "next/server";
import Stripe from "stripe";
import { getOrCreateUid } from "../../_session";

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, { apiVersion: "2024-06-20" });

export async function POST(_req: NextRequest) {
  const uid = getOrCreateUid();

  // Find a customer by metadata.uid (requires you attach it when creating/subscribing)
  const customers = await stripe.customers.list({ limit: 100 }); // naive; fine for small scale
  const customer = customers.data.find(c => (c.metadata as any)?.uid === uid);

  if (!customer) return NextResponse.json({ error: "No customer found" }, { status: 404 });

  const portal = await stripe.billingPortal.sessions.create({
    customer: customer.id,
    return_url: process.env.NEXT_PUBLIC_SITE_URL!,
  });

  return NextResponse.json({ url: portal.url });
}


Note: The billing portal lookup is simplistic. For production, store customer.id in KV on checkout completion and use it directly.

13) app/api/stripe/webhook/route.ts
import { NextRequest, NextResponse } from "next/server";
import Stripe from "stripe";
import { getKV } from "@/lib/kv";

export const runtime = "nodejs"; // webhooks need Node runtime

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, { apiVersion: "2024-06-20" });

export async function POST(req: NextRequest) {
  const rawBody = await req.text();
  const sig = req.headers.get("stripe-signature")!;
  let event: Stripe.Event;

  try {
    event = stripe.webhooks.constructEvent(rawBody, sig, process.env.STRIPE_WEBHOOK_SECRET!);
  } catch (err: any) {
    return new NextResponse(`Webhook Error: ${err.message}`, { status: 400 });
  }

  const kv = getKV();

  switch (event.type) {
    case "checkout.session.completed": {
      const session = event.data.object as Stripe.Checkout.Session;
      const uid = (session.metadata as any)?.uid;
      if (uid) {
        // Mark premium and attach uid to customer for portal
        await kv.set(`premium:${uid}`, true);
        if (session.customer) {
          const customerId = typeof session.customer === "string" ? session.customer : session.customer.id;
          await stripe.customers.update(customerId, { metadata: { uid } });
          await kv.set(`stripeCustomerFor:${uid}`, customerId);
        }
      }
      break;
    }
    case "customer.subscription.deleted":
    case "customer.subscription.paused":
    case "customer.subscription.unpaid": {
      // Find uid for this customer and revoke premium
      const sub = event.data.object as Stripe.Subscription;
      const customerId = typeof sub.customer === "string" ? sub.customer : sub.customer.id;
      // Reverse lookup via KV we saved earlier
      // (In production: also store customer->uid mapping at checkout)
      // We'll scan a small set by reading kv.get with known keys if you persist them.
      // For simplicity assume you stored mapping:
      // kv.set(`uidFor:${customerId}`, uid) and kv.set(`stripeCustomerFor:${uid}`, customerId)
      // Try both directions:
      let uid = await kv.get<string>(`uidFor:${customerId}`);
      if (!uid) {
        // attempt reverse search (not efficient, but ok for MVP if not available)
        // skip expensive search; just no-op if unknown
        break;
      }
      await kv.set(`premium:${uid}`, false);
      break;
    }
  }

  return NextResponse.json({ received: true });
}


Tip: After checkout completion, also set both:

kv.set("uidFor:<customerId>", uid)

kv.set("stripeCustomerFor:<uid>", customerId)

Add those two in the checkout.session.completed handler for robust mapping.

Replace that block with:

await kv.set(`premium:${uid}`, true);
if (session.customer) {
  const customerId = typeof session.customer === "string" ? session.customer : session.customer.id;
  await stripe.customers.update(customerId, { metadata: { uid } });
  await kv.set(`stripeCustomerFor:${uid}`, customerId);
  await kv.set(`uidFor:${customerId}`, uid);
}

14) (Optional) app/api/health/route.ts
export function GET() {
  return new Response("ok");
}

15) Minimal styles (optional) app/globals.css
:root { color-scheme: dark; }
* { box-sizing: border-box; }

16) Deploy Steps

Stripe

Create a Product and Recurring Price ($5/mo).

Put the price_... into STRIPE_PRICE_ID.

Get a Webhook Signing Secret from Stripe (for checkout.session.completed and subscription events) â†’ set STRIPE_WEBHOOK_SECRET.

Vercel

Import the repo, add env vars from .env.local.

Add Vercel KV integration.

Deploy.

Local Dev (optional)

npm run dev
# in another terminal:
npm run stripe:listen

How it works (quick)

A device-level uid is stored in an HttpOnly cookie.

Free users can do 5 analyses (counted in KV on usage:<uid>).

Stripe checkout stores a mapping via webhook and marks premium:<uid> = true.

/api/analyze runs your GPT with the SafeMessage AI system prompt and returns the formatted block, plus parsed verdict/threat for UI.

If you want me to include file uploads (screenshots + OCR) next, I can extend /api/analyze using Vision models and add a dropzone on the UI.

If you paste these in and set your env vars, you should be live on Vercel with free+premium tiers tied to your GPT engine. Enjoy!
